#Tests algues
# -*- coding: utf-8 -*-

"""
/***************************************************************************
 AquaticPlantsDetector
                                 A QGIS plugin
 This plugin will be part of a workflow that will allow the user to detect aquatic plants in a body of water from satellite images
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-04-01
        copyright            : (C) 2025 by Liam Messier & Jeremy Tem
        email                : Liam.Messier@Usherbrooke.ca
 ***************************************************************************/


"""

__author__ = 'Liam Messier & Jeremy Tem'
__date__ = '2025-04-01'
__copyright__ = '(C) 2025 by Liam Messier & Jeremy Tem'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtGui import QColor
from qgis.core import (QgsProcessingException,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterString,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterRasterDestination,
                       QgsRasterLayer,
                       QgsProject,
                       QgsSingleBandPseudoColorRenderer,
                       QgsRasterShader,
                       QgsColorRampShader)
from qgis.analysis import (QgsRasterCalculator, 
                           QgsRasterCalculatorEntry)
import os
import tempfile
from osgeo import gdal
import numpy as np


class AquaticPlantsDetectorAlgorithm(QgsProcessingAlgorithm):
    """
    This algorithm calculates the Normalized Difference Algae Index (NDAI)
    from Sentinel-2 imagery and filters the output based on user-defined thresholds.
    """

    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'
    NDAI = 'NDAI'

    def initAlgorithm(self, config):
        """
        Define the inputs and outputs of the algorithm.
        """
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                self.tr('Input Sentinel-2 raster layer')
            )
        )

        self.addParameter(
            QgsProcessingParameterString(
                self.NDAI,
                self.tr('List of NDAI threshold values (e.g., 0.5,0.8)')
            )
        )

        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr('Output filtered NDAI raster')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Perform the NDAI calculation and filtering.
        """

        # Retrieve input parameters
        raster_layer = self.parameterAsRasterLayer(parameters, self.INPUT, context)
        ndai_thresholds = self.parameterAsString(parameters, self.NDAI, context)
        output_path = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)

        # Validate input raster
        feedback.pushInfo(f'Input raster has {raster_layer.bandCount()} bands.')
        if raster_layer.bandCount() < 5:
            raise QgsProcessingException('Input raster does not have the required Sentinel-2 bands (B2, B3, B4, B8).')

        # Parse NDAI thresholds
        try:
            ndai_min, ndai_max = map(float, ndai_thresholds.split(','))
        except ValueError:
            raise QgsProcessingException('Invalid NDAI threshold values. Provide two comma-separated numbers.')

        # Prepare raster calculator entries for Sentinel-2 bands
        entries = []
        for band, name in [(2, 'B2'), (3, 'B3'), (4, 'B4'), (5, 'B8')]:
            entry = QgsRasterCalculatorEntry()
            entry.ref = f'{raster_layer.name()}@{band}'
            entry.raster = raster_layer
            entry.bandNumber = band
            entries.append(entry)
        
        #Display entries
        feedback.pushInfo(f'Entries: {entries}')

        # NDAI formula: ((G + 2NIR - B - R) / (G + 2NIR + B + R)) + 0.5
        ndai_formula = f"(({entries[1].ref} + 2 * {entries[3].ref} - {entries[0].ref} - {entries[2].ref}) / " \
                       f"({entries[1].ref} + 2 * {entries[3].ref} + {entries[0].ref} + {entries[2].ref})) + 0.5"
        feedback.pushInfo(f'NDAI formula: {ndai_formula}')

        # Temporary path for NDAI raster
        temp_ndai_path = os.path.join(tempfile.gettempdir(), 'ndai.tif')
        feedback.pushInfo(f'Temporary file path: {temp_ndai_path}')

        # Perform raster calculation for NDAI
        calculator = QgsRasterCalculator(
            ndai_formula,
            temp_ndai_path,
            'GTiff',
            raster_layer.extent(),
            raster_layer.width(),
            raster_layer.height(),
            entries
        )
        result = calculator.processCalculation(feedback)

        # Check if the calculation was successful
        if result != 0:
            raise QgsProcessingException(f'Raster calculation failed with error code: {result}')
        
        # Filter NDAI values based on thresholds
        feedback.pushInfo('Filtering NDAI values...')
        self.filter_ndai(temp_ndai_path, ndai_min, ndai_max, output_path, feedback)

        # Apply symbology to the output NDAI raster
        self.apply_symbology(output_path, feedback)

        return {self.OUTPUT: output_path}

    def filter_ndai(self, ndai_path, ndai_min, ndai_max, output_path, feedback):
        """
        Filters the NDAI raster based on threshold values.
        """

        # Check if the file exists
        if not os.path.exists(ndai_path):
            raise QgsProcessingException(f'Temporary NDAI file not found: {ndai_path}')

        # Open the NDAI raster
        ndai_ds = gdal.Open(ndai_path)
        if ndai_ds is None:
            raise QgsProcessingException(f'Failed to open NDAI raster: {ndai_path}')

        ndai_band = ndai_ds.GetRasterBand(1)
        ndai_data = ndai_band.ReadAsArray()

        # Apply threshold filtering
        feedback.pushInfo('Applying NDAI thresholds...')
        filtered_data = np.where((ndai_data >= ndai_min) & (ndai_data <= ndai_max), ndai_data, 0)

        # Save the filtered raster
        driver = gdal.GetDriverByName('GTiff')
        out_ds = driver.Create(output_path, ndai_ds.RasterXSize, ndai_ds.RasterYSize, 1, gdal.GDT_Float32)
        out_ds.SetGeoTransform(ndai_ds.GetGeoTransform())
        out_ds.SetProjection(ndai_ds.GetProjection())
        out_band = out_ds.GetRasterBand(1)
        out_band.WriteArray(filtered_data)
        out_band.SetNoDataValue(0)  # Set NoData value to 0
        out_band.FlushCache()

        # Clean up
        ndai_ds = None
        out_ds = None

    def apply_symbology(self, raster_path, feedback):
        """
        Applies the Green-Blue (GnBu) color palette to the NDAI raster.
        """
        feedback.pushInfo('Applying symbology to the NDAI raster...')

        # Load the raster layer
        raster_layer = QgsRasterLayer(raster_path, 'NDAI Raster')
        if not raster_layer.isValid():
            raise QgsProcessingException(f'Failed to load raster layer: {raster_path}')

        # Create a color ramp shader
        shader = QgsRasterShader()
        color_ramp = QgsColorRampShader()
        color_ramp.setColorRampType(QgsColorRampShader.Interpolated)

        # Define the color ramp (GnBu palette)
        color_ramp.setColorRampItemList([
            QgsColorRampShader.ColorRampItem(0, QColor(247, 252, 240), 'Low'),
            QgsColorRampShader.ColorRampItem(0.25, QColor(204, 235, 197), 'Low-Mid'),
            QgsColorRampShader.ColorRampItem(0.5, QColor(168, 221, 181), 'Mid'),
            QgsColorRampShader.ColorRampItem(0.75, QColor(123, 204, 196), 'Mid-High'),
            QgsColorRampShader.ColorRampItem(1, QColor(43, 140, 190), 'High')
        ])
        shader.setRasterShaderFunction(color_ramp)

        # Apply the shader to the raster layer
        renderer = QgsSingleBandPseudoColorRenderer(raster_layer.dataProvider(), 1, shader)
        raster_layer.setRenderer(renderer)

        # Refresh the layer to apply the symbology
        raster_layer.triggerRepaint()

        # Add the layer to the QGIS project
        QgsProject.instance().addMapLayer(raster_layer)
        feedback.pushInfo('Symbology applied successfully.')

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm.
        """
        return 'aquatic_plants_detector'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to.
        """
        return 'aquatic_plants'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return AquaticPlantsDetectorAlgorithm()
